#include <stdint.h>

#define MIN(a,b) ((a) < (b) ? (a) : (b))

// Generated by the Tensor Algebra Compiler (tensor-compiler.org)
// taco "A(i,j)=B(i,k)*C(k,j)" -f=A:dd:0,1 -f=B:ds:0,1 -f=C:uq:0,1

// Modified to remove references to `taco_tensor_t` by passing everything as func args
// Added comments

void compute(int B1_dimension,
             int A2_dimension,
             double* restrict A_vals,

             // B is in CSR
             int* restrict B2_pos,
             int* restrict B2_crd,
             double* restrict B_vals,

             // C is in COO
             int* restrict C1_pos,
             int* restrict C1_crd,
             int* restrict C2_crd,
             double* restrict C_vals) {

    // For every row of B
    for (int i = 0; i < B1_dimension; i++) {

        // B: nonzero column indices are in the RANGE [B_pos[i], B_pos[i + 1])
        int kB = B2_pos[i];
        int pB2_end = B2_pos[i + 1];

        // kC is reset to 0, pC1_end is the number of ALL nonzero elements in C
        int kC = C1_pos[0];
        int pC1_end = C1_pos[1];

        while (kB < pB2_end && kC < pC1_end) {

            // kB0: column index in B
            int32_t kB0 = B2_crd[kB];

            // kC0: row index in C
            int32_t kC0 = C1_crd[kC];

            int32_t k = MIN(kB0,kC0);

            // Count nonzero elements of C in row k
            int32_t C1_segend = kC;
            while (C1_segend < pC1_end && C1_crd[C1_segend] == k) {
                C1_segend++;
            }

            // If C has nonzero elements in row k
            if (kB0 == k && kC0 == k) {

                // Partial computation of A[i,j] based on element B[i, k] and row C[k, j]
                for (int32_t jC = kC; jC < C1_segend; jC++) {
                    int32_t j = C2_crd[jC];
                    int32_t jA = i * A2_dimension + j;
                    A_vals[jA] = A_vals[jA] + B_vals[kB] * C_vals[jC];
                }

            }

            // Non-affine loop
            kB += (int32_t)(kB0 == k);
            kC += C1_segend;
        }
    }
}
