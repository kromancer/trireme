From a3932fdc76cdcdbb9aaf7dedba20939c4ee3b8ca Mon Sep 17 00:00:00 2001
From: Konstantinos Sotiropoulos <konstantinos.sotiropoulos@chalmers.se>
Date: Thu, 27 Jun 2024 11:09:09 +0200
Subject: [PATCH] [mlir][sparse] Add pref that for SpMV (csr) and SpMM (csr x
 csr)

---
 .../Transforms/Utils/LoopEmitter.cpp          | 48 ++++++++++++++++++-
 1 file changed, 47 insertions(+), 1 deletion(-)

diff --git a/mlir/lib/Dialect/SparseTensor/Transforms/Utils/LoopEmitter.cpp b/mlir/lib/Dialect/SparseTensor/Transforms/Utils/LoopEmitter.cpp
index 2be0193f0de8..3c1ba7351886 100644
--- a/mlir/lib/Dialect/SparseTensor/Transforms/Utils/LoopEmitter.cpp
+++ b/mlir/lib/Dialect/SparseTensor/Transforms/Utils/LoopEmitter.cpp
@@ -686,9 +686,55 @@ Operation *LoopEmitter::enterCoIterationOverTensorsAtLvls(
   }
 
   // Enter dense tensor levels.
-  for (SparseIterator *it : raIters)
+  for (SparseIterator *it : raIters) {
     it->locate(builder, loc, iv);
 
+    if (auto loadOp = dyn_cast_or_null<memref::LoadOp>(iv.getDefiningOp())) {
+      const auto indices = loadOp.getIndices();
+      assert(indices.size() == 1 && "Expected crd buffers to have one index");
+
+      assert(spIters.size() == 1 && "Expected only one sparse iterator");
+      auto [_, upperB] = spIters.front()->genForCond(builder, loc) ;
+
+      const auto crdBuf = loadOp.getMemRef();
+
+      const auto stt = getSparseTensorType(tensors[it->tid]);
+      const Level lvlRank = stt.getLvlRank();
+      const bool isLastLvl = it->lvl >= lvlRank - 1;
+      const unsigned prefDist = isLastLvl ? 32 : 1;
+
+      // Prefetch B2_crd[jB + 2 * dist]
+      auto doubleDist = C_IDX(prefDist * 2);
+      auto plusDoubleDist = ADDI(indices[0], doubleDist);
+      builder.create<memref::PrefetchOp>(loc, crdBuf, plusDoubleDist.getResult(), false, 0, true);
+
+      // Load B2_crd[min(j + dist, j_end)]
+      auto dist = C_IDX(prefDist);
+      auto plusDist = ADDI(indices[0], dist);
+      auto cmp = CMPI(ult, plusDist, upperB);
+      auto min = SELECT(cmp, plusDist, upperB);
+      auto prefIdx = builder.create<memref::LoadOp>(loc, crdBuf, min.getResult());
+
+      // Prefetch c_vals[B2_crd[%B2_crd_jB_plus_dist_or_pB2_end]]
+      SmallVector<Value> prefIndices;
+      bool isWrite = false;
+      Value posOrValbuf;
+      if (isLastLvl) {
+        posOrValbuf = getValBuffer()[it->tid];
+        if (isOutputTensor(it->tid))
+          isWrite = true;
+        SmallVector<Value> valPosits = getValPosits(it->tid);
+        prefIndices.append(valPosits.begin(), valPosits.begin() + it->lvl);
+      } else {
+        const auto &stl = *lvls[it->tid][it->lvl + 1];
+        posOrValbuf = stl.getLvlBuffers()[0]; // Pos buffer
+      }
+
+      prefIndices.push_back(prefIdx.getResult());
+      builder.create<memref::PrefetchOp>(loc, posOrValbuf, prefIndices, isWrite, 0, true);
+    }
+  }
+
   // NOTE: we can also prepare for next dim here in advance
   // Pushes the loop into stack.
   loopStack.emplace_back(tls, l, builder.getInsertionBlock(), iv, loopTag);
-- 
2.45.2

